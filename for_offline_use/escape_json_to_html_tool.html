<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Skill-Station – Escape JSON → Offline-HTML</title>

  <!-- Tool-UI nutzt dein Shared Theme -->
  <style id="__ASSET_SHARED_THEME__">
/**
 * ============================================================================
 * shared_theme.css - Globales Theme-System für Skill-Station
 * ============================================================================
 * 
 * ZWECK:
 * ------
 * Diese Datei definiert das zentrale Design-System für die gesamte Anwendung.
 * Sie verwendet CSS Custom Properties (Variablen) für ein konsistentes,
 * wartbares und theme-fähiges Design.
 * 
 * DESIGN-PHILOSOPHIE:
 * -------------------
 * - **Glassmorphism**: Halbtransparente Elemente mit Blur-Effekten
 * - **Cyber-Aesthetik**: Neon-Glows und elektrische Akzente
 * - **HSL-Farbsystem**: Flexible Farbmanipulation über Hue-Sat-Lightness
 * - **Dark/Light Mode**: Vollständige Theme-Unterstützung
 * 
 * VERWENDUNG:
 * -----------
 * Diese Datei sollte in jeder HTML-Datei eingebunden werden:
 *   <link rel="stylesheet" href="shared_theme.css">
 * 
 * oder für Dateien im games-Ordner:
 *   <link rel="stylesheet" href="../shared_theme.css">
 * 
 * THEME-WECHSEL:
 * --------------
 * Füge die Klasse 'theme-light' zum <html>-Element hinzu:
 *   document.documentElement.classList.add('theme-light');
 * 
 * Für Dark Mode entferne die Klasse:
 *   document.documentElement.classList.remove('theme-light');
 * 
 * VERFÜGBARE KOMPONENTEN:
 * -----------------------
 * - .card / .section-card: Glassmorphismus-Karten
 * - .btn / .btn.primary: Buttons mit Glow-Effekten
 * - input / select / textarea: Styled Form-Elemente
 * - .section-status: Status-Pills mit Farb-Varianten
 * 
 * CSS-VARIABLEN VERWENDEN:
 * ------------------------
 * In deinem eigenen CSS kannst du die Variablen nutzen:
 *   background: hsl(var(--bg-surface) / 0.5);
 *   color: hsl(var(--primary));
 *   border: 1px solid hsl(var(--glass-border));
 * 
 * NEUE FARBEN HINZUFÜGEN:
 * -----------------------
 * 1. Definiere die Farbe in :root als HSL-Triplet:
 *    --my-color: 120 80% 50%;
 * 
 * 2. Optional: Überschreibe sie in :root.theme-light:
 *    --my-color: 120 40% 30%;
 * 
 * 3. Verwende sie in deinen Styles:
 *    color: hsl(var(--my-color));
 * 
 * PERFORMANCE-TIPPS:
 * ------------------
 * - backdrop-filter: blur() ist performance-intensiv, verwende es sparsam
 * - Glow-Effekte (box-shadow) können bei vielen Elementen FPS beeinflussen
 * - Transformations (translateY, scale) sind GPU-beschleunigt = performant
 * 
 * ============================================================================
 */

:root {
    /* 
       HSL Color System - "Cyber-Glass" Edition
       High Transparency & Neon Glows
       
       WARUM HSL?
       ----------
       HSL (Hue, Saturation, Lightness) ist ideal für Theme-Systeme:
       - Hue: Der Farbton (0-360°)
       - Saturation: Die Sättigung (0-100%)
       - Lightness: Die Helligkeit (0-100%)
       
       Dies ermöglicht einfache Anpassungen:
       - Hellere Variante: Lightness erhöhen
       - Gedämpftere Farbe: Saturation verringern
       - Transparenz: "/" Syntax verwenden
       
       VERWENDUNG:
       -----------
       Statt: color: hsl(195, 100%, 60%);
       Nutze: color: hsl(var(--primary)); /* nutzt die Variable */

    /*Mit Transparenz:*/
        background: hsl(var(--primary) / 0.5);
    /* 50% transparent */
    /**!*/
    /* Brand / Accent - Cyan/Electric Blue */
    --primary-hue: 195;
    --primary-sat: 100%;
    --primary-lig: 60%;

    --primary: var(--primary-hue) var(--primary-sat) var(--primary-lig);
    --primary-fg: 0 0% 100%;

    /* Base - Deep Space Dark */
    --bg-hue: 230;
    --bg-sat: 30%;
    --bg-lig: 6%;

    --bg: var(--bg-hue) var(--bg-sat) var(--bg-lig);

    /* Surface Colors - Base opacity 0.3 for glass feel */
    --bg-surface: 230 30% 15%;
    --bg-surface-alpha: 0.75;
    /* 25% opacity = 75% transparent */
    --bg-surface-2-alpha: 0.35;

    /* Text */
    --txt: 210 50% 98%;
    --txt-muted: 215 30% 75%;
    /* Brighter muted for contrast on dark */

    /* Status */
    --success: 142 80% 50%;
    --error: 0 90% 65%;

    /* Sizing */
    --radius-sm: 0.5rem;
    --radius-md: 0.75rem;
    --radius-lg: 1.25rem;

    /* Shadows & Glows */
    --shadow-sm: 0 4px 6px -1px rgba(0, 0, 0, 0.3);

    /* Neon Glows */
    --glow-primary: 0 0 15px hsl(var(--primary) / 0.6), 0 0 30px hsl(var(--primary) / 0.3);
    --glow-text: 0 0 10px hsl(var(--primary) / 0.8);
    --glow-border: 0 0 8px hsl(var(--primary) / 0.4);

    /* Glass Vars */
    --glass-bg: 230 30% 10%;
    --glass-opacity: 0.85;
    /* Extremely transparent (85%) */
    --glass-border: 210 50% 30%;
    --glass-blur: 20px;
}

/* Light Theme Override - Kept "Frosty" */
:root.theme-light {
    --bg-hue: 210;
    --bg-sat: 30%;
    --bg-lig: 95%;

    --bg: var(--bg-hue) var(--bg-sat) var(--bg-lig);

    /* FIX: gültige HSL-Werte für Light-Theme-Flächen */
    --bg-surface: 0 0% 100%;
    --bg-surface-alpha: 0.4;
    --bg-surface-2-alpha: 0.5;

    --txt: 222 47% 11%;
    --txt-muted: 215 16% 47%;

    /* FIX: gültige HSL-Werte für Glas-Hintergrund im Light-Theme */
    --glass-bg: 0 0% 100%;
    --glass-opacity: 0.3;
    --glass-border: 214 32% 80%;

    --glow-primary: 0 4px 20px hsl(var(--primary) / 0.4);
    --glow-text: none;
}

/* --- Global Resets & Typography --- */
body {
    background-color: hsl(var(--bg));
    color: hsl(var(--txt));
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    transition: background-color 0.3s ease, color 0.3s ease;
    margin: 0;
    line-height: 1.6;
    -webkit-font-smoothing: antialiased;
}

* {
    box-sizing: border-box;
}

/* --- Components --- */

/* Cards - Glassy */
.card,
.section-card {
    background: hsl(var(--bg-surface) / var(--bg-surface-alpha));
    backdrop-filter: blur(var(--glass-blur));
    -webkit-backdrop-filter: blur(var(--glass-blur));
    border: 1px solid hsl(var(--glass-border) / 0.5);
    border-radius: var(--radius-lg);
    padding: 1.5rem;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    /* Glass shadow */
    margin-bottom: 1.5rem;
    color: hsl(var(--txt));
    transition: border-color 0.3s, box-shadow 0.3s;
}

.card:hover {
    border-color: hsl(var(--glass-border));
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), inset 0 0 20px rgba(255, 255, 255, 0.02);
}

.card h2,
.section-title {
    margin-top: 0;
    font-size: 1.25rem;
    font-weight: 700;
    letter-spacing: -0.025em;
    color: hsl(var(--txt));
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

.section-sub {
    color: hsl(var(--txt-muted));
    font-size: 0.925rem;
    margin-bottom: 1rem;
}

/* Buttons */
.btn {
    appearance: none;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.6rem 1.2rem;
    border-radius: var(--radius-md);
    font-weight: 600;
    font-size: 0.925rem;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    background: hsl(var(--bg-surface) / 0.3);
    color: hsl(var(--txt));
    border: 1px solid hsl(var(--glass-border));
    text-decoration: none;
    backdrop-filter: blur(4px);
}

.btn:hover:not(:disabled) {
    transform: translateY(-2px);
    border-color: hsl(var(--primary));
    box-shadow: var(--glow-primary);
    color: hsl(var(--primary));
    text-shadow: 0 0 8px hsl(var(--primary) / 0.5);
    background: hsl(var(--bg-surface) / 0.5);
}

.btn:active:not(:disabled) {
    transform: translateY(0);
}

.btn.primary {
    background: hsl(var(--primary) / 0.8);
    color: hsl(var(--primary-fg));
    border-color: transparent;
    box-shadow: 0 0 20px hsl(var(--primary) / 0.4);
}

.btn.primary:hover:not(:disabled) {
    filter: brightness(1.2);
    box-shadow: 0 0 30px hsl(var(--primary) / 0.6);
}

/* Inputs */
input,
select,
textarea {
    background: hsl(var(--bg-surface) / 0.8);
    border: 1px solid hsl(var(--glass-border));
    color: hsl(var(--txt));
    padding: 0.6rem 0.8rem;
    border-radius: var(--radius-md);
    font-size: 0.95rem;
    width: 100%;
    transition: all 0.3s;
    backdrop-filter: blur(4px);
}

input:focus,
select:focus,
textarea:focus {
    outline: none;
    border-color: hsl(var(--primary));
    box-shadow: var(--glow-primary);
    background: hsl(var(--bg-surface) / 0.8);
}

/* Status Pills */
.section-status {
    font-size: 0.7rem;
    padding: 0.25rem 0.75rem;
    border-radius: 999px;
    background: hsl(var(--bg-surface) / 0.7);
    border: 1px solid hsl(var(--glass-border));
    text-transform: uppercase;
    font-weight: 700;
    letter-spacing: 0.05em;
    color: hsl(var(--txt-muted));
    display: inline-block;
    backdrop-filter: blur(4px);
}

.section-status--done {
    background: hsl(var(--success) / 0.85);
    color: hsl(var(--success));
    border-color: hsl(var(--success) / 0.4);
    box-shadow: 0 0 10px hsl(var(--success) / 0.2);
}

.section-status--fail {
    background: hsl(var(--error) / 0.85);
    color: hsl(var(--error));
    border-color: hsl(var(--error) / 0.4);
    box-shadow: 0 0 10px hsl(var(--error) / 0.2);
}
  </style>

  <style>
    .tool-wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 18px;
    }
    .tool-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    .tool-card {
      padding: 14px;
    }
    textarea.tool-text {
      width: 100%;
      min-height: 420px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
      line-height: 1.4;
    }
    .tool-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }
    .tool-note {
      color: hsl(var(--txt-muted));
      font-size: 12px;
      margin-top: 8px;
    }
    @media (max-width: 980px) {
      .tool-grid { grid-template-columns: 1fr; }
      textarea.tool-text { min-height: 320px; }
    }
  </style>

  <!-- Assets für das generierte Offline-Game -->
  <script id="__ASSET_ESCAPE_CSS__" type="text/plain">
/* Scrollbar Styling */
::-webkit-scrollbar {
    width: 14px;
}

::-webkit-scrollbar-track {
    background: var(--bg);
}

::-webkit-scrollbar-thumb {
    background-color: var(--border-strong);
    border: 4px solid var(--bg);
    border-radius: 99px;
}

::-webkit-scrollbar-thumb:hover {
    background-color: var(--muted);
}

/* Escape-Game.css - Refactored for Theme Toggle Support */

:root {
    /* --- Core Palette (Dark / Default) --- */
    --bg: #020617;
    --panel: rgba(15, 23, 42, 0.96);
    --panel-soft: rgba(15, 23, 42, 0.85);
    --border-soft: rgba(148, 163, 184, 0.35);
    --border-strong: rgba(148, 163, 184, 0.65);
    --accent: #38bdf8;
    --accent-soft: rgba(56, 189, 248, 0.18);
    --accent-strong: #0ea5e9;
    --text: #e5e7eb;
    --muted: #9ca3af;
    --error: #f97373;
    --success: #22c55e;
    --shadow-soft: 0 18px 60px rgba(15, 23, 42, 0.9);

    --radius-lg: 24px;
    --radius-md: 18px;
    --radius-sm: 999px;

    /* --- Component Variables --- */

    /* Backgrounds */
    --body-bg-gradient:
            radial-gradient(circle at top, rgba(148, 163, 184, 0.15), transparent 55%),
            radial-gradient(circle at bottom, rgba(56, 189, 248, 0.12), transparent 60%),
            var(--bg);

    /* Panels & Cards */
    --panel-bg: radial-gradient(circle at top left, rgba(148, 163, 184, 0.18), transparent 55%) var(--panel);
    --card-glass-bg: radial-gradient(circle at top left, rgba(148, 163, 184, 0.12), transparent 60%) rgba(15, 23, 42, 0.90);

    /* Chips & Buttons */
    --stat-chip-bg: radial-gradient(circle at top, rgba(148, 163, 184, 0.18), transparent 55%), rgba(15, 23, 42, 0.75);

    --btn-secondary-bg: radial-gradient(circle at top left, rgba(56, 189, 248, 0.22), transparent 55%) rgba(15, 23, 42, 0.9);
    --btn-secondary-hover-bg: radial-gradient(circle at top left, rgba(56, 189, 248, 0.35), transparent 60%) rgba(15, 23, 42, 0.98);
    --btn-footer-bg: radial-gradient(circle at top left, rgba(56, 189, 248, 0.22), transparent 55%) rgba(37, 99, 235, 0.05);

    /* Door Scene */
    --door-scene-bg: radial-gradient(circle at top, rgba(248, 250, 252, 0.10), transparent 60%) rgba(15, 23, 42, 0.9);
    --door-sign-bg: rgba(15, 23, 42, 0.9);
    --door-bg: linear-gradient(145deg, rgba(15, 23, 42, 0.7), rgba(15, 23, 42, 0.4));
    --door-floor-bg: radial-gradient(circle at top, rgba(15, 23, 42, 0.9), transparent 70%);
    --door-shadow-color: rgba(56, 189, 248, 0.7);

    /* Sort & Play Area */
    --sort-pool-bg: radial-gradient(circle at top, rgba(148, 163, 184, 0.09), transparent 60%);
    --dropzone-bg: rgba(15, 23, 42, 0.82);
    --dropzone-over-bg: radial-gradient(circle at top, rgba(56, 189, 248, 0.18), transparent 65%) rgba(15, 23, 42, 0.96);
    --drag-card-bg: radial-gradient(circle at top, rgba(148, 163, 184, 0.18), transparent 70%) rgba(15, 23, 42, 0.95);

    /* Inputs */
    --input-bg: rgba(15, 23, 42, 0.95);
    --input-gradient-image: linear-gradient(45deg, transparent 50%, var(--muted) 52%), linear-gradient(135deg, var(--muted) 48%, transparent 50%);
}

/* Light Theme Overrides */
:root.theme-light {
    --bg: #f8fafc;
    --panel: rgba(255, 255, 255, 0.92);
    --panel-soft: rgba(255, 255, 255, 0.85);
    --border-soft: rgba(51, 65, 85, 0.2);
    --border-strong: rgba(51, 65, 85, 0.4);
    --accent: #0ea5e9;
    --accent-soft: rgba(14, 165, 233, 0.15);
    --accent-strong: #0284c7;
    --text: #0f172a;
    --muted: #64748b;
    --shadow-soft: 0 10px 30px rgba(51, 65, 85, 0.15);

    /* Component Overrides (Light) */
    --body-bg-gradient:
            radial-gradient(circle at top, rgba(14, 165, 233, 0.1), transparent 55%),
            radial-gradient(circle at bottom, rgba(99, 102, 241, 0.08), transparent 60%),
            var(--bg);

    --panel-bg: radial-gradient(circle at top left, rgba(148, 163, 184, 0.12), transparent 55%) var(--panel);
    --card-glass-bg: radial-gradient(circle at top left, rgba(255, 255, 255, 0.8), transparent 60%) rgba(255, 255, 255, 0.90);

    --stat-chip-bg: radial-gradient(circle at top, rgba(200, 200, 200, 0.2), transparent 55%), rgba(255, 255, 255, 0.85);

    --btn-secondary-bg: radial-gradient(circle at top left, rgba(14, 165, 233, 0.1), transparent 55%) rgba(255, 255, 255, 0.9);
    --btn-secondary-hover-bg: radial-gradient(circle at top left, rgba(14, 165, 233, 0.2), transparent 60%) rgba(255, 255, 255, 1.0);
    --btn-footer-bg: radial-gradient(circle at top left, rgba(14, 165, 233, 0.15), transparent 55%) rgba(255, 255, 255, 0.8);

    --door-scene-bg: radial-gradient(circle at top, rgba(14, 165, 233, 0.08), transparent 60%) rgba(255, 255, 255, 0.85);
    --door-sign-bg: rgba(255, 255, 255, 0.95);
    --door-bg: linear-gradient(145deg, rgba(241, 245, 249, 1), rgba(226, 232, 240, 1));
    --door-floor-bg: radial-gradient(circle at top, rgba(51, 65, 85, 0.2), transparent 70%);
    --door-shadow-color: rgba(14, 165, 233, 0.7);

    --sort-pool-bg: radial-gradient(circle at top, rgba(14, 165, 233, 0.08), transparent 60%) rgba(255, 255, 255, 0.4);
    --dropzone-bg: rgba(255, 255, 255, 0.8);
    --dropzone-over-bg: radial-gradient(circle at top, rgba(14, 165, 233, 0.2), transparent 65%) rgba(255, 255, 255, 0.95);
    --drag-card-bg: radial-gradient(circle at top, rgba(255, 255, 255, 0.9), transparent 70%) rgba(255, 255, 255, 0.95);

    --input-bg: rgba(255, 255, 255, 0.95);
    --input-gradient-image: linear-gradient(45deg, transparent 50%, var(--muted) 52%), linear-gradient(135deg, var(--muted) 48%, transparent 50%);
}

/* Grundlayout */

*,
*::before,
*::after {
    box-sizing: border-box;
}

html,
body {
    height: 100%;
    margin: 0;
}

body {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    color: var(--text);
    background: var(--bg);
    margin: 0;
    padding: 0;
    min-height: 100vh;
}

/* Außenrahmen / Board */

.page {
    width: 100%;
    min-height: 100vh;
}

.panel {
    background: var(--panel-bg);
    background-blend-mode: soft-light;
    min-height: 100vh;
    width: 100%;
    border: none;
    box-shadow: none;
    border-radius: 0;
    padding: 2rem;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.game-content {
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
}

/* Header oben */

.header {
    display: flex;
    justify-content: space-between;
    gap: 2rem;
    align-items: flex-start;
}

.title-block {
    display: none;
}

.header {
    justify-content: flex-end;
}

.stats {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    align-items: flex-end;
}

/* Stats-Chips */

.stat-chip {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.6rem;
    padding: 0.4rem 1.1rem;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border-soft);
    background: var(--stat-chip-bg);
    font-size: 0.9rem;
    white-space: nowrap;
    transition: background 0.3s ease, border-color 0.3s ease;
}

.stat-chip span:first-child {
    color: var(--muted);
}

.stat-chip--timer span:last-child {
    font-variant-numeric: tabular-nums;
}

/* Toolbar / Restart-Button */

.toolbar {
    display: flex;
    justify-content: flex-end;
    margin-top: 1.25rem;
    margin-bottom: 1.5rem;
}

.btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.55rem;
    border-radius: var(--radius-sm);
    border: 1px solid transparent;
    padding: 0.55rem 1.4rem;
    font-size: 0.95rem;
    cursor: pointer;
    transition: background 0.15s ease, border-color 0.15s ease, transform 0.08s ease, box-shadow 0.15s ease, color 0.15s ease;
    font-weight: 500;
    color: var(--text);
}

.btn span:first-child {
    font-size: 1.05em;
}

.btn-secondary {
    background: var(--btn-secondary-bg);
    border-color: var(--accent-soft);
    color: var(--accent-strong);
    box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.05), 0 14px 30px rgba(15, 23, 42, 0.2);
}

.btn-secondary:hover {
    background: var(--btn-secondary-hover-bg);
    transform: translateY(-1px);
    box-shadow: 0 18px 40px rgba(15, 23, 42, 0.3);
}

.btn:active {
    transform: translateY(0);
    box-shadow: 0 10px 20px rgba(15, 23, 42, 0.1);
}

/* Tür-Karte */

.door-wrapper {
    margin-bottom: 1.75rem;
}

.door-scene {
    width: 160px;
    height: 210px;
    border-radius: var(--radius-md);
    background: var(--door-scene-bg);
    border: 1px solid var(--border-soft);
    box-shadow: 0 20px 45px rgba(15, 23, 42, 0.3);
    position: relative;
    padding-top: 2.2rem;
    margin-left: 0.25rem;
    transition: background 0.3s ease, border-color 0.3s ease;
}

.door-sign {
    position: absolute;
    top: 1.15rem;
    left: 50%;
    transform: translateX(-50%);
    padding: 0.25rem 0.9rem;
    border-radius: var(--radius-sm);
    font-size: 0.75rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    border: 1px solid rgba(248, 113, 113, 0.6);
    color: rgba(248, 113, 113, 0.9);
    background: var(--door-sign-bg);
    z-index: 2;
    transition: background 0.3s ease;
}

.door-sign--open {
    border-color: rgba(34, 197, 94, 0.7);
    color: rgba(134, 239, 172, 0.9);
}

.door {
    width: 76px;
    height: 120px;
    border-radius: 18px;
    border: 2px solid var(--border-strong);
    margin: 0 auto;
    position: relative;
    background: var(--door-bg);
    box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.1);
    z-index: 1;
    transition: background 0.3s ease, border-color 0.3s ease;
}

.door::after {
    content: "";
    position: absolute;
    width: 8px;
    height: 8px;
    border-radius: 999px;
    background: var(--accent);
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
    box-shadow: 0 0 10px var(--door-shadow-color);
}

.door--open {
    transform: perspective(600px) rotateY(-20deg) translateX(-6px);
    transform-origin: left center;
    transition: transform 0.35s ease-out;
}

.door-floor {
    position: absolute;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    width: 120px;
    height: 22px;
    background: var(--door-floor-bg);
    opacity: 0.85;
    transition: background 0.3s ease;
}

.door-glow {
    position: absolute;
    inset: auto 8px 8px;
    height: 26px;
    border-radius: 999px;
    background: radial-gradient(circle at center, rgba(56, 189, 248, 0.0), transparent 70%);
    opacity: 0;
    pointer-events: none;
}

.door-glow--active {
    background: radial-gradient(circle at center, rgba(56, 189, 248, 0.23), transparent 75%);
    opacity: 1;
}

/* Grid */

.layout-grid {
    display: flex;
    flex-direction: column;
    gap: 1.4rem;
}

/* Section Cards */

.section-card {
    background: var(--card-glass-bg);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-soft);
    box-shadow: 0 14px 40px rgba(15, 23, 42, 0.2);
    padding: 1.3rem 1.5rem 1.4rem;
    backdrop-filter: blur(18px) saturate(150%);
    -webkit-backdrop-filter: blur(18px) saturate(150%);
    transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 1rem;
    margin-bottom: 1rem;
}

.section-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text);
}

.section-sub {
    font-size: 0.9rem;
    color: var(--muted);
    margin-top: 0.2rem;
}

.section-status {
    font-size: 0.8rem;
    padding: 0.25rem 0.8rem;
    border-radius: var(--radius-sm);
    border: 1px solid rgba(148, 163, 184, 0.4);
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.06em;
}

.section-status--done {
    border-color: rgba(34, 197, 94, 0.7);
    color: rgba(134, 239, 172, 0.9);
    background: rgba(22, 163, 74, 0.15);
}

.section-status--fail {
    border-color: rgba(248, 113, 113, 0.7);
    color: rgba(248, 113, 113, 0.95);
    background: rgba(127, 29, 29, 0.28);
}

.section-body {
    margin-bottom: 1rem;
}

.section-footer {
    margin-top: 0.3rem;
}

/* Sortier-Aufgabe */

.sort-pool {
    border-radius: 18px;
    border: 1px dashed rgba(148, 163, 184, 0.5);
    background: var(--sort-pool-bg);
    padding: 0.75rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.6rem;
    margin-bottom: 1rem;
    transition: background 0.3s ease;
}

.sort-board {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 0.9rem;
}

.escape-dropzone {
    border-radius: 18px;
    border: 1px dashed rgba(148, 163, 184, 0.6);
    background: var(--dropzone-bg);
    padding: 0.75rem 0.9rem;
    min-height: 80px;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    transition: border-color 0.15s ease, background 0.15s ease, box-shadow 0.15s ease;
}

.escape-dropzone-label {
    font-size: 0.9rem;
    font-weight: 500;
    color: var(--text);
}

.escape-dropzone-label span {
    display: block;
    margin-top: 0.1rem;
}

.escape-dropzone.is-over {
    border-style: solid;
    border-color: var(--accent);
    box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.35);
    background: var(--dropzone-over-bg);
}

/* Drag-Karten */

.drag-card {
    border-radius: 12px;
    padding: 0.5rem 0.9rem;
    font-size: 0.9rem;
    border: 1px solid rgba(148, 163, 184, 0.7);
    background: var(--drag-card-bg);
    box-shadow: 0 10px 20px rgba(15, 23, 42, 0.2);
    cursor: grab;
    user-select: none;
    display: inline-flex;
    align-items: center;
    justify-content: flex-start;
    max-width: 100%;
    height: auto;
    color: var(--text);
    transition: background 0.3s ease, border-color 0.3s ease, color 0.3s ease;
}

.drag-card.dragging {
    opacity: 0.85;
    transform: scale(1.03);
    cursor: grabbing;
}

.drag-card.correct {
    border-color: rgba(34, 197, 94, 0.9);
    box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.6), 0 14px 28px rgba(22, 163, 74, 0.5);
}

.drag-card.wrong {
    border-color: rgba(248, 113, 113, 0.9);
    box-shadow: 0 0 0 1px rgba(248, 113, 113, 0.6), 0 14px 28px rgba(127, 29, 29, 0.65);
}

.drag-card-text {
    white-space: normal;
    line-height: 1.35;
    text-align: left;
}

/* Quiz-Bereich */

.quiz-question {
    max-width: 60rem;
}

.quiz-options {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.35rem;
}

.quiz-options li {
    display: block;
    width: 100%;
    margin: 0.25rem 0;
}

.quiz-options li label {
    display: inline-flex !important;
    align-items: flex-start;
    gap: 0.5rem;
    width: 100%;
    cursor: pointer;
    font-size: 0.92rem;
    max-width: 100%;
    white-space: normal;
    color: var(--text);
}

.quiz-options li input[type="radio"] {
    flex: 0 0 auto !important;
    width: auto;
    margin-top: 0.2rem;
    margin-right: 0;
    accent-color: var(--accent);
    order: 0;
}

/* Capital-Tabelle */

.capital-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.93rem;
}

.capital-table th {
    text-align: left;
    padding-bottom: 0.4rem;
    font-weight: 500;
    color: var(--muted);
}

.capital-table td {
    padding: 0.3rem 0;
    color: var(--text);
}

.capital-table select {
    width: 100%;
    border-radius: 999px;
    border: 1px solid var(--border-soft);
    background: var(--input-bg);
    color: var(--text);
    padding: 0.35rem 0.85rem;
    font-size: 0.9rem;
    outline: none;
    box-shadow: 0 8px 18px rgba(15, 23, 42, 0.2);
    appearance: none;
    -webkit-appearance: none;
    background-image: var(--input-gradient-image);
    background-position: calc(100% - 14px) 55%, calc(100% - 9px) 55%;
    background-size: 7px 7px, 7px 7px;
    background-repeat: no-repeat;
    cursor: pointer;
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
}

.capital-table select.correct {
    border-color: rgba(34, 197, 94, 0.9);
    box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.6), 0 14px 30px rgba(22, 163, 74, 0.7);
}

.capital-table select.wrong {
    border-color: rgba(248, 113, 113, 0.95);
    box-shadow: 0 0 0 1px rgba(248, 113, 113, 0.7), 0 14px 30px rgba(127, 29, 29, 0.7);
}

/* Buttons in den Section-Footern */

.section-footer .btn {
    background: var(--btn-footer-bg);
    border-color: var(--accent);
    color: var(--accent-strong);
    padding-inline: 1.5rem;
}

.section-footer .btn:hover {
    background: var(--btn-secondary-hover-bg);
}

/* Kleinere Screens */

@media (max-width: 900px) {
    .panel {
        padding: 1.5rem 1.25rem 1.75rem;
    }

    .header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1.1rem;
    }

    .stats {
        flex-direction: row;
        align-items: center;
        justify-content: flex-start;
    }

    .sort-board {
        grid-template-columns: 1fr;
    }

    .door-scene {
        margin-bottom: 1rem;
    }
}

  </script>

  <script id="__ASSET_GAME_BASE_JS__" type="text/plain">
(function () {
  'use strict';

  const THEME_KEY = 'globalTheme_v1';
  const JSON_SESSION_PREFIX = 'game_payload_';

  function applyStoredTheme() {
    try {
      const stored = localStorage.getItem(THEME_KEY);
      const theme = (stored === 'light' || stored === 'dark') ? stored : 'dark';
      if (theme === 'light') document.documentElement.classList.add('theme-light');
      else document.documentElement.classList.remove('theme-light');
    } catch (_) { /* ignore */ }
  }

  class GameBase {
    constructor(opts) {
      this.opts = opts || {};
      this.expectedGameType = this.opts.expectedGameType || null;
      this.rootElementId = this.opts.rootElementId || null;
      this._inited = false;
    }

    init() {
      if (this._inited) return;
      this._inited = true;

      const boot = () => {
        applyStoredTheme();

        try {
          const payload = this._loadPayload();
          if (!payload) throw new Error('Kein JSON-Payload gefunden.');

          if (this.expectedGameType && payload.game_type && payload.game_type !== this.expectedGameType) {
            throw new Error(`Falscher game_type: erwartet "${this.expectedGameType}", bekommen "${payload.game_type}".`);
          }

          this.onDataLoaded(payload);
        } catch (err) {
          this._renderFatal(err);
        }
      };

      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
      else boot();
    }

    // Overwrite in game
    onDataLoaded(_data) {}

    _loadPayload() {
      // 1) window.GAME_PAYLOAD
      if (window.GAME_PAYLOAD && typeof window.GAME_PAYLOAD === 'object') return window.GAME_PAYLOAD;

      // 2) embedded <script type="application/json" id="__GAME_PAYLOAD__">
      const embedded = document.getElementById('__GAME_PAYLOAD__');
      if (embedded && embedded.textContent && embedded.textContent.trim()) {
        try { return JSON.parse(embedded.textContent); } catch (_) { /* ignore */ }
      }

      // 3) sessionStorage via ?fileId=... (online-kompatibel)
      const params = new URLSearchParams(location.search);
      const fileId = params.get('fileId') || params.get('id');
      if (fileId) {
        const raw = sessionStorage.getItem(JSON_SESSION_PREFIX + fileId);
        if (raw) {
          try { return JSON.parse(raw); } catch (_) { /* ignore */ }
        }
      }

      // 4) ?payload=... (URI-encoded JSON oder Base64(JSON))
      const payloadParam = params.get('payload');
      if (payloadParam) {
        try {
          const decoded = decodeURIComponent(payloadParam);
          return JSON.parse(decoded);
        } catch (_) { /* ignore */ }

        try {
          const decoded = atob(payloadParam);
          return JSON.parse(decoded);
        } catch (_) { /* ignore */ }
      }

      return null;
    }

    _renderFatal(err) {
      console.error(err);
      const msg = String(err && err.message ? err.message : err);

      const target = (this.rootElementId && document.getElementById(this.rootElementId)) ? document.getElementById(this.rootElementId) : document.body;

      const wrap = document.createElement('div');
      wrap.style.cssText = [
        'max-width: 980px',
        'margin: 24px auto',
        'padding: 16px',
        'border-radius: 16px',
        'border: 1px solid rgba(255, 0, 0, .35)',
        'background: rgba(0, 0, 0, .35)',
        'backdrop-filter: blur(10px)',
        'color: var(--text, #fff)',
        'font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'
      ].join(';');

      const title = document.createElement('div');
      title.style.cssText = 'font-size: 18px; font-weight: 700; margin-bottom: 10px; color: hsl(var(--error, 0 80% 60%));';
      title.textContent = 'Game konnte nicht starten';

      const pre = document.createElement('pre');
      pre.style.cssText = 'margin: 0; white-space: pre-wrap;';
      pre.textContent = msg;

      wrap.appendChild(title);
      wrap.appendChild(pre);
      target.prepend(wrap);
    }
  }

  window.GameBase = GameBase;
})();
  </script>

  <script id="__ASSET_ESCAPE_JS__" type="text/plain">
(function () {
    'use strict';

    class EscapeGame extends window.GameBase {
        constructor() {
            super({
                expectedGameType: 'escape_game',
                rootElementId: 'game-root'
            });

            // Game State
            this.START_SECONDS = 180;
            this.remainingSeconds = this.START_SECONDS;
            this.timerId = null;
            this.gameLocked = false;

            // Generic section tracking
            // We store solution data by section ID
            this.sectionData = {};
            this.solvedSections = new Set();
            this.totalSections = 0;

            this.draggingCardId = null;

            // DOM Elements
            this.statTimerEl = null;
            this.statSolvedEl = null;
            this.doorEl = null;
            this.doorSignEl = null;
            this.doorGlowEl = null;
            this.puzzleContainer = null;
        }

        onDataLoaded(data) {
            // 1. Setup global stats
            this.statTimerEl = document.getElementById("stat-timer");
            this.statSolvedEl = document.getElementById("stat-solved");

            this.doorEl = document.getElementById("door");
            this.doorSignEl = document.getElementById("door-sign");
            this.doorGlowEl = document.getElementById("door-glow");

            this.puzzleContainer = document.getElementById("puzzle-container");

            // Buttons
            const restartBtn = document.getElementById("restart-btn");
            if (restartBtn) restartBtn.addEventListener("click", () => this.resetGame());

            // 2. Render Sections
            this.renderSections(data.sections || []);

            // 3. Start
            this.resetGame();
        }

        renderSections(sections) {
            this.puzzleContainer.innerHTML = "";
            this.sectionData = {};
            this.totalSections = sections.length;
            this.solvedSections.clear();

            sections.forEach(section => {
                // Determine container
                const sectionEl = document.createElement("section");
                sectionEl.className = "section-card";
                sectionEl.id = `section-${section.id}`; // consistent ID for styling if needed

                // Header
                const header = document.createElement("div");
                header.className = "section-header";
                header.innerHTML = `
                    <div>
                        <div class="section-title">${section.title || 'Rätsel'}</div>
                        <div class="section-sub">${section.subtitle || ''}</div>
                    </div>
                    <div class="section-status" id="status-${section.id}">offen</div>
                `;
                sectionEl.appendChild(header);

                // Body container
                const body = document.createElement("div");
                body.className = "section-body";
                sectionEl.appendChild(body);

                // Footer container
                const footer = document.createElement("div");
                footer.className = "section-footer";
                sectionEl.appendChild(footer);

                // Check button
                const checkBtn = document.createElement("button");
                checkBtn.className = "btn";
                checkBtn.type = "button";
                checkBtn.innerHTML = `<span>✔</span> Prüfen`;
                checkBtn.addEventListener("click", () => this.checkSection(section.id));
                footer.appendChild(checkBtn);

                // Render specific type
                if (section.type === "sort") {
                    this.renderSort(section, body);
                } else if (section.type === "quiz") {
                    this.renderQuiz(section, body);
                } else if (section.type === "capital") {
                    this.renderCapital(section, body);
                } else {
                    body.textContent = "Unknown Type: " + section.type;
                }

                // Store data for validation
                this.sectionData[section.id] = section;
                this.puzzleContainer.appendChild(sectionEl);
            });
        }

        // --- Renderers ---

        renderSort(section, container) {
            // Pool
            const pool = document.createElement("div");
            pool.className = "sort-pool";
            pool.id = `pool-${section.id}`;
            container.appendChild(pool);

            // Board
            const board = document.createElement("div");
            board.className = "sort-board";
            container.appendChild(board);

            // Create Zones
            (section.sortColumns || []).forEach(col => {
                const zone = document.createElement("div");
                zone.className = "escape-dropzone";
                zone.dataset.zone = col.zone;

                // Drag Events
                zone.addEventListener("dragover", (e) => this.handleDragOverZone(e));
                zone.addEventListener("dragleave", (e) => this.handleDragLeaveZone(e));
                zone.addEventListener("drop", (e) => this.handleDropZone(e));

                const label = document.createElement("div");
                label.className = "escape-dropzone-label";
                label.innerHTML = `${col.label}<br><span style="font-size:10px;color:hsl(var(--txt-muted));">${col.hint || ''}</span>`;
                zone.appendChild(label);
                board.appendChild(zone);
            });

            // Populate Cards (Initial) in resetGame usually, but can do here if we just reset later
            // We just store cards data in sectionData and let resetGame handle filling the pool? 
            // Better: Render them now, resetGame essentially just moves them back.
            // Actually resetGame triggers "resetSortBoard" for all sort sections.
        }

        renderQuiz(section, container) {
            (section.questions || []).forEach(q => {
                const qDiv = document.createElement("div");
                qDiv.className = "quiz-question";
                qDiv.dataset.quizId = q.id;

                const text = document.createElement("div");
                text.className = "quiz-text";
                text.textContent = q.text;
                qDiv.appendChild(text);

                const ul = document.createElement("ul");
                ul.className = "quiz-options";
                (q.options || []).forEach(opt => {
                    const li = document.createElement("li");
                    li.innerHTML = `<label><input type="radio" name="${section.id}_${q.id}" value="${opt.value}"> ${opt.text}</label>`;
                    ul.appendChild(li);
                });
                qDiv.appendChild(ul);
                container.appendChild(qDiv);
            });
            const feedback = document.createElement("div");
            feedback.className = "quiz-feedback";
            feedback.id = `feedback-${section.id}`;
            feedback.textContent = section.hintDefault || "Wähle je Frage eine Antwort";
            container.appendChild(feedback);
        }

        renderCapital(section, container) {
            // Table structure
            const table = document.createElement("table");
            table.className = "capital-table";
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>${section.col1Title || 'Item'}</th>
                        <th>${section.col2Title || 'Zuordnung'}</th>
                    </tr>
                </thead>
                <tbody></tbody>
            `;
            const tbody = table.querySelector("tbody");

            (section.rows || []).forEach(row => {
                const tr = document.createElement("tr");
                const tdLabel = document.createElement("td");
                tdLabel.textContent = row.label;
                const tdInput = document.createElement("td");

                const select = document.createElement("select");
                select.dataset.rowKey = row.key;
                select.dataset.sectionId = section.id;

                // Options
                (row.options || []).forEach(opt => {
                    const option = document.createElement("option");
                    option.value = opt.value;
                    option.textContent = opt.text;
                    select.appendChild(option);
                });

                tdInput.appendChild(select);
                tr.appendChild(tdLabel);
                tr.appendChild(tdInput);
                tbody.appendChild(tr);
            });
            container.appendChild(table);
        }

        // --- Timer logic (mostly same) ---
        startTimer() {
            if (this.timerId) clearInterval(this.timerId);
            this.timerId = setInterval(() => this.tickTimer(), 1000);
        }

        tickTimer() {
            if (this.gameLocked) return;
            this.remainingSeconds -= 1;
            if (this.remainingSeconds <= 0) {
                this.remainingSeconds = 0;
                this.updateTimerDisplay();
                this.handleTimeUp();
                return;
            }
            this.updateTimerDisplay();
        }

        updateTimerDisplay() {
            if (!this.statTimerEl) return;
            this.statTimerEl.textContent = this.formatTime(this.remainingSeconds);
            this.statTimerEl.style.color = this.remainingSeconds <= 10 ? 'hsl(var(--error))' : 'var(--text)';
        }

        formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s);
        }

        handleTimeUp() {
            if (this.timerId) { clearInterval(this.timerId); this.timerId = null; }
            this.gameLocked = true;
            this.doorSignEl.textContent = "ZU SPÄT";
            this.doorSignEl.classList.remove("door-sign--open");
            this.doorSignEl.classList.add("door-sign--closed");
            this.doorEl.classList.remove("door--open");
            this.doorGlowEl.classList.remove("door-glow--active");
            this._disableAllButtons();
        }

        _disableAllButtons() {
            document.querySelectorAll(".section-footer .btn").forEach(b => b.disabled = true);
        }

        _enableAllButtons() {
            document.querySelectorAll(".section-footer .btn").forEach(b => b.disabled = false);
        }

        // --- Game Logic ---

        updateSolvedStatus() {
            const count = this.solvedSections.size;
            this.statSolvedEl.textContent = `${count} / ${this.totalSections}`;

            if (count === this.totalSections && !this.gameLocked && this.remainingSeconds > 0) {
                this.openDoor();
            }
        }

        openDoor() {
            this.gameLocked = true;
            if (this.timerId) clearInterval(this.timerId);
            this.doorEl.classList.add("door--open");
            this.doorGlowEl.classList.add("door-glow--active");
            this.doorSignEl.textContent = "OFFEN";
            this.doorSignEl.classList.remove("door-sign--closed");
            this.doorSignEl.classList.add("door-sign--open");
            this._disableAllButtons();
        }

        resetGame() {
            if (this.timerId) clearInterval(this.timerId);
            this.remainingSeconds = this.START_SECONDS;
            this.gameLocked = false;
            this.solvedSections.clear();

            // UI Reset
            this.updateTimerDisplay();
            this.statSolvedEl.textContent = `0 / ${this.totalSections}`;

            this.doorEl.classList.remove("door--open");
            this.doorGlowEl.classList.remove("door-glow--active");
            this.doorSignEl.textContent = "GESCHLOSSEN";
            this.doorSignEl.classList.add("door-sign--closed");
            this.doorSignEl.classList.remove("door-sign--open");

            // Reset each section
            Object.values(this.sectionData).forEach(section => {
                const statusEl = document.getElementById(`status-${section.id}`);
                if (statusEl) {
                    statusEl.textContent = "offen";
                    statusEl.className = "section-status";
                }

                if (section.type === "sort") {
                    this.resetSortBoard(section);
                } else if (section.type === "quiz") {
                    // Uncheck radios
                    document.querySelectorAll(`input[name^="${section.id}_"]`).forEach(i => i.checked = false);
                    const fb = document.getElementById(`feedback-${section.id}`);
                    if (fb) fb.textContent = section.hintDefault || "";
                } else if (section.type === "capital") {
                    // Reset selects
                    const table = document.querySelector(`#section-${section.id} table`);
                    if (table) {
                        table.querySelectorAll("select").forEach(sel => {
                            sel.value = "";
                            sel.classList.remove("correct", "wrong");
                        });
                    }
                }
            });

            this._enableAllButtons();
            this.startTimer();
        }

        checkSection(sectionId) {
            if (this.gameLocked) return;

            const section = this.sectionData[sectionId];
            if (!section) return;

            let solved = false;
            if (section.type === "sort") solved = this.checkSort(section);
            else if (section.type === "quiz") solved = this.checkQuiz(section);
            else if (section.type === "capital") solved = this.checkCapital(section);

            const statusEl = document.getElementById(`status-${sectionId}`);
            if (solved) {
                this.solvedSections.add(sectionId);
                statusEl.textContent = "gelöst";
                statusEl.className = "section-status section-status--done";
            } else {
                this.solvedSections.delete(sectionId);
                statusEl.textContent = "noch Fehler";
                statusEl.className = "section-status section-status--fail";
            }
            this.updateSolvedStatus();
        }

        // --- Specific Checks ---

        checkSort(section) {
            let correctCount = 0;
            const cardData = section.sortCards || [];
            const total = cardData.length;

            // Reset visual state
            // Find all cards for this section? Actually cards have unique IDs. 
            // But we need to make sure we only target cards belonging to this section if we had multiple sort puzzles.
            // Currently IDs are global in JSON. Assuming IDs unique. To be safe, scope search.
            const sectionEl = document.getElementById(`section-${section.id}`);
            const cards = sectionEl.querySelectorAll(".drag-card");
            cards.forEach(c => c.classList.remove("correct", "wrong"));

            let allCorrect = true;

            // Loop through DATA to check where each card is
            cardData.forEach(card => {
                const el = sectionEl.querySelector(`.drag-card[data-card-id="${card.id}"]`);
                if (!el) {
                    allCorrect = false;
                    return;
                }

                const parentZone = el.closest(".escape-dropzone");
                if (!parentZone) {
                    el.classList.add("wrong");
                    allCorrect = false;
                    return;
                }

                const zoneName = parentZone.dataset.zone;
                if (zoneName === card.correctZone) {
                    el.classList.add("correct");
                } else {
                    el.classList.add("wrong");
                    allCorrect = false;
                }
            });

            return allCorrect;
        }

        checkQuiz(section) {
            const questions = section.questions || [];
            let allCorrect = true;

            questions.forEach(q => {
                const selected = document.querySelector(`input[name="${section.id}_${q.id}"]:checked`);
                const userVal = selected ? selected.value : null;
                if (userVal !== q.correct) {
                    allCorrect = false;
                }
            });

            const fb = document.getElementById(`feedback-${section.id}`);
            if (fb) {
                fb.textContent = allCorrect ? "Alles richtig!" : "Mindestens eine Antwort ist falsch/fehlt.";
            }
            return allCorrect;
        }

        checkCapital(section) {
            const rows = section.rows || [];
            let allCorrect = true;
            const sectionEl = document.getElementById(`section-${section.id}`);
            const selects = sectionEl.querySelectorAll("select");

            selects.forEach(sel => sel.classList.remove("correct", "wrong"));

            rows.forEach(row => {
                const sel = sectionEl.querySelector(`select[data-row-key="${row.key}"]`);
                if (!sel) return;

                if (sel.value === row.correct) {
                    sel.classList.add("correct");
                } else {
                    sel.classList.add("wrong");
                    allCorrect = false;
                }
            });
            return allCorrect;
        }

        // --- Drag & Drop Helpers ---

        resetSortBoard(section) {
            const pool = document.getElementById(`pool-${section.id}`);
            if (!pool) return;
            pool.innerHTML = "";

            const sectionEl = document.getElementById(`section-${section.id}`);
            // Clear dropzones
            sectionEl.querySelectorAll(".escape-dropzone").forEach(z => {
                z.classList.remove("is-over");
                // Remove drag cards only
                const cards = z.querySelectorAll(".drag-card");
                cards.forEach(c => c.remove());
            });

            // Re-create cards in pool
            (section.sortCards || []).forEach(cardData => {
                const el = this.createSortCard(cardData);
                pool.appendChild(el);
            });
        }

        createSortCard(cardData) {
            const el = document.createElement("div");
            el.className = "drag-card";
            el.draggable = true;
            el.dataset.cardId = cardData.id;

            const span = document.createElement("span");
            span.className = "drag-card-text";
            span.textContent = cardData.text;
            el.appendChild(span);

            el.addEventListener("dragstart", (e) => {
                if (this.gameLocked) { e.preventDefault(); return; }
                this.draggingCardId = cardData.id;
                el.classList.add("dragging");
                e.dataTransfer.effectAllowed = "move";
                e.dataTransfer.setData("text/plain", cardData.id);
            });

            el.addEventListener("dragend", () => {
                this.draggingCardId = null;
                el.classList.remove("dragging");
            });
            return el;
        }

        handleDragOverZone(e) {
            if (this.gameLocked) return;
            e.preventDefault();
            e.dataTransfer.dropEffect = "move";
            e.currentTarget.classList.add("is-over");
        }

        handleDragLeaveZone(e) {
            e.currentTarget.classList.remove("is-over");
        }

        handleDropZone(e) {
            if (this.gameLocked) return;
            e.preventDefault();
            const zone = e.currentTarget;
            zone.classList.remove("is-over");

            const cardId = e.dataTransfer.getData("text/plain") || this.draggingCardId;
            if (!cardId) return;

            // Find card anywhere in document (or better, scoped to current puzzle?)
            // Since we know drag started and stored draggingCardId, and ID is unique:
            const cardEl = document.querySelector(`.drag-card[data-card-id="${cardId}"]`);
            if (!cardEl) return;

            cardEl.classList.remove("correct", "wrong");
            zone.appendChild(cardEl);
        }
    }

    const game = new EscapeGame();
    game.init();

})();

  </script>
</head>

<body>
  <div class="page" id="game-root">
    <main class="panel">
      <div class="tool-wrap">
        <header class="header" style="margin-bottom: 12px;">
          <div class="title-block">
            <h1>Escape JSON → Offline-HTML</h1>
            <p>JSON rein, fertige Offline-HTML raus (inkl. CSS/JS). Öffne Tool und erzeugte Datei einfach per Doppelklick.</p>
          </div>
          <div class="stats">
            <div class="stat-chip">
              <span>Game</span>
              <span>escape_game</span>
            </div>
          </div>
        </header>

        <div class="tool-grid">
          <section class="card tool-card">
            <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
              <h2 style="margin:0;font-size:16px;">Input JSON</h2>
              <label class="btn-secondary btn" style="margin:0;cursor:pointer;">
                JSON-Datei wählen
                <input id="fileInput" type="file" accept=".json,application/json" style="display:none;">
              </label>
            </div>

            <textarea id="jsonInput" class="tool-text" placeholder='{ ... }'></textarea>

            <div class="tool-actions">
              <button id="btnGenerate" class="btn primary" type="button">HTML generieren</button>
              <button id="btnDownload" class="btn" type="button" disabled>HTML herunterladen</button>
              <button id="btnClear" class="btn-secondary btn" type="button">Leeren</button>
            </div>

            <div id="errBox" class="tool-note" style="color:hsl(var(--error));display:none;"></div>
            <div class="tool-note">Hinweis: Erzeugt eine <b>komplett selbstständige</b> HTML-Datei (alles inline). Kein Hardcoding von Beispiel-JSON.</div>
          </section>

          <section class="card tool-card">
            <h2 style="margin:0 0 8px 0;font-size:16px;">Output HTML</h2>
            <textarea id="htmlOutput" class="tool-text" readonly placeholder="Hier erscheint die generierte Offline-HTML..."></textarea>
            <div class="tool-note">Wenn dein Browser Downloads aus <code>file://</code> blockt: Output kopieren und als <code>.html</code> speichern.</div>
          </section>
        </div>
      </div>
    </main>
  </div>

<script>
(function () {
  'use strict';

  const END_SCRIPT = '</scr' + 'ipt>';

  const jsonInput = document.getElementById('jsonInput');
  const htmlOutput = document.getElementById('htmlOutput');
  const btnGenerate = document.getElementById('btnGenerate');
  const btnDownload = document.getElementById('btnDownload');
  const btnClear = document.getElementById('btnClear');
  const errBox = document.getElementById('errBox');
  const fileInput = document.getElementById('fileInput');

  const sharedThemeCss = document.getElementById('__ASSET_SHARED_THEME__').textContent;
  const escapeCss = document.getElementById('__ASSET_ESCAPE_CSS__').textContent;
  const gameBaseJs = document.getElementById('__ASSET_GAME_BASE_JS__').textContent;
  const escapeJs = document.getElementById('__ASSET_ESCAPE_JS__').textContent;

  let lastGeneratedHtml = '';

  function showError(msg) {
    errBox.style.display = 'block';
    errBox.textContent = String(msg || 'Fehler');
  }

  function clearError() {
    errBox.style.display = 'none';
    errBox.textContent = '';
  }

  function safeFileName(title) {
    const base = (title || 'Escape-Game-offline').toString().trim() || 'Escape-Game-offline';
    return base
      .replace(/\s+/g, ' ')
      .replace(/[\\/:*?"<>|]/g, '')
      .slice(0, 80)
      .trim()
      .replace(/\s+/g, '_')
      + '.html';
  }

  function escapeScriptClose(s) {
    // schützt eingebettetes JSON vor </script>
    return String(s).replace(/<\/script/gi, '<\\/script');
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function buildOfflineEscapeHtml(payload) {
    const title = payload && payload.title ? String(payload.title) : 'Mini-Escape-Game';
    const json = JSON.stringify(payload, null, 2);

    return `<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>${escapeHtml(title)}</title>

  <style>
${sharedThemeCss}
  </style>

  <style>
${escapeCss}
  </style>
</head>

<body>
  <div class="page" id="game-root">
    <main class="panel">
      <div class="game-content">
        <header class="header">
          <div class="title-block">
            <h1>Mini-Escape-Room</h1>
            <p>Löse alle Aufgaben, bevor die Zeit ebgelaufen ist</p>
          </div>
          <div class="stats">
            <div class="stat-chip stat-chip--timer">
              <span>Zeit</span>
              <span id="stat-timer">03:00</span>
            </div>
            <div class="stat-chip">
              <span>Rätsel gelöst</span>
              <span id="stat-solved">0 / 0</span>
            </div>
          </div>
        </header>

        <div class="toolbar">
          <button class="btn-secondary btn" id="restart-btn" type="button">
            <span>↻</span> Neu starten
          </button>
        </div>

        <div class="door-wrapper">
          <div class="door-scene">
            <div class="door-sign door-sign--closed" id="door-sign">GESCHLOSSEN</div>
            <div class="door" id="door"></div>
            <div class="door-floor"></div>
            <div class="door-glow" id="door-glow"></div>
          </div>
        </div>

        <div class="layout-grid" id="puzzle-container"></div>
      </div>
    </main>
  </div>

  <script id="__GAME_PAYLOAD__" type="application/json">
${escapeScriptClose(json)}
  ${END_SCRIPT}

  <script>
${gameBaseJs}
  ${END_SCRIPT}

  <script>
${escapeJs}
  ${END_SCRIPT}
</body>
</html>`;
  }

  function parsePayload() {
    const raw = jsonInput.value.trim();
    if (!raw) throw new Error('JSON-Input ist leer.');
    let payload;
    try {
      payload = JSON.parse(raw);
    } catch (e) {
      throw new Error('JSON ist ungültig (Parse-Fehler).');
    }
    if (!payload || typeof payload !== 'object') throw new Error('JSON ist kein Objekt.');
    if (payload.game_type && payload.game_type !== 'escape_game') {
      throw new Error('Dieses Tool ist aktuell nur für game_type = "escape_game".');
    }
    return payload;
  }

  btnGenerate.addEventListener('click', () => {
    clearError();
    try {
      const payload = parsePayload();
      lastGeneratedHtml = buildOfflineEscapeHtml(payload);
      htmlOutput.value = lastGeneratedHtml;
      btnDownload.disabled = false;
    } catch (e) {
      btnDownload.disabled = true;
      lastGeneratedHtml = '';
      htmlOutput.value = '';
      showError(e.message || e);
    }
  });

  btnDownload.addEventListener('click', () => {
    clearError();
    if (!lastGeneratedHtml) return;

    let payloadTitle = '';
    try {
      const p = JSON.parse(jsonInput.value);
      payloadTitle = p && p.title ? p.title : '';
    } catch (_) {}

    const filename = safeFileName(payloadTitle || 'Escape-Game-offline');

    const blob = new Blob([lastGeneratedHtml], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(() => URL.revokeObjectURL(url), 1000);
  });

  btnClear.addEventListener('click', () => {
    clearError();
    jsonInput.value = '';
    htmlOutput.value = '';
    lastGeneratedHtml = '';
    btnDownload.disabled = true;
  });

  fileInput.addEventListener('change', async (e) => {
    clearError();
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    try {
      const text = await file.text();
      jsonInput.value = text;
    } catch (err) {
      showError('Konnte Datei nicht lesen.');
    } finally {
      fileInput.value = '';
    }
  });
})();
</script>
</body>
</html>
